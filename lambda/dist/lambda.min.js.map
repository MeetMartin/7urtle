{"version":3,"sources":["webpack://lambda/webpack/universalModuleDefinition","webpack://lambda/webpack/bootstrap","webpack://lambda/./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://lambda/./node_modules/@babel/runtime/helpers/createClass.js","webpack://lambda/./node_modules/@babel/runtime/helpers/inherits.js","webpack://lambda/./node_modules/@babel/runtime/helpers/getPrototypeOf.js","webpack://lambda/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","webpack://lambda/./node_modules/@babel/runtime/helpers/typeof.js","webpack://lambda/./node_modules/@babel/runtime/helpers/defineProperty.js","webpack://lambda/./node_modules/@babel/runtime/helpers/setPrototypeOf.js","webpack://lambda/./node_modules/@babel/runtime/helpers/assertThisInitialized.js","webpack://lambda/./src/arity.js","webpack://lambda/./src/conditional.js","webpack://lambda/./src/utils.js","webpack://lambda/./src/list.js","webpack://lambda/./src/core.js","webpack://lambda/./src/string.js","webpack://lambda/./src/Case.js","webpack://lambda/./src/Maybe.js","webpack://lambda/./src/Either.js","webpack://lambda/./src/SyncEffect.js","webpack://lambda/./src/AsyncEffect.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","instance","Constructor","TypeError","_defineProperties","target","props","length","descriptor","configurable","writable","protoProps","staticProps","setPrototypeOf","subClass","superClass","constructor","_getPrototypeOf","getPrototypeOf","__proto__","_typeof","assertThisInitialized","self","obj","iterator","_setPrototypeOf","ReferenceError","nary","fn","args","reduce","accumulator","current","isEqual","a","b","isNotEqual","isDeepEqual","deepInspect","isNotDeepEqual","isTrue","isFalse","isGreaterThan","isLessThan","isAtLeast","isAtMost","isTypeOf","typeOf","isNotTypeOf","isString","isNotString","isBoolean","isNotBoolean","isNull","isNotNull","isUndefined","isNotUndefined","isNumber","isNotNumber","isObject","isNotObject","isArray","Array","isNotArray","isFunction","isNotFunction","isLength","lengthOf","isNotLength","isEmpty","isNotEmpty","isZero","isNotZero","isNothing","isJust","passThrough","anything","log","console","spy","minusOneToUndefined","undefined","inspectFunction","String","inspectArray","join","map","inspectString","inspectObject","inspect","k","keysOf","initial","reducer","list","reduceRight","mapper","filter","checker","find","findIndex","separator","keys","entriesOf","entries","everyOf","every","slice","end","start","someOf","some","identity","compose","fns","v","f","pipe","functorMap","functor","functorFlatMap","flatMap","liftA2","ap1","ap2","ap","liftA3","ap3","concat","includes","indexOf","lastIndexOf","memoize","memory","trim","string","testRegEx","regex","test","substr","limit","firstLetterOf","lastLetterOf","startsWith","substring","endsWith","repeat","count","replace","replacement","search","split","lowerCaseOf","toLowerCase","upperCaseOf","toUpperCase","Case","x","match","result","Map","Maybe","Nothing","Just","of","maybe","error","onJust","functorMaybe","Either","Right","Left","e","message","either","onLeft","onRight","functorEither","isLeft","SyncEffect","trigger","AsyncEffect","reject","resolve","Promise"],"mappings":"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","file":"lambda.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"lambda\"] = factory();\n\telse\n\t\troot[\"lambda\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","/**\r\n * nary takes input of a curried function and allows it to be called both as curried and n-ary.\r\n *\r\n * @HindleyMilner nary :: (a -> b) -> a -> b\r\n *\r\n * @pure\r\n * @param {function} fn\r\n * @return {function}\r\n *\r\n * @example\r\n * import {nary} from '@7urtle/lambda';\r\n *\r\n * const fn1 = nary(a => b => a + b);\r\n * fn1('a')('b') === fn1('a', 'b'); // => true\r\n */\r\nexport const nary = fn =>\r\n    (...args) => args.length === 0\r\n        ? fn()\r\n        : args.reduce((accumulator, current) => accumulator(current), fn);","import {typeOf, lengthOf, deepInspect} from \"./utils\";\nimport {nary} from \"./arity\";\n\n/**\n * isEqual output is true if strict equality between a and b is true. isEqual output is always false for comparison\n * of objects and arrays.\n *\n * isEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isEqual} from '@7urtle/lambda';\n *\n * isEqual('something')('something'); // => true\n * isEqual('something')('something else'); // => false\n * isEqual(['a'])(['a']); // => false\n * isEqual({a : 'something'})({a : 'something'}); // => false\n *\n * // isEqual can be called both as a curried unary function or as a standard binary function\n * isEqual('something')('something') === isEqual('something', 'something');\n */\nexport const isEqual = nary(a => b => a === b);\n\n/**\n * isNotEqual output is true if strict equality between a and b is false. isNotEqual output is always true for\n * comparison of objects and arrays.\n *\n * isEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isNotEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isNotEqual} from '@7urtle/lambda';\n *\n * isNotEqual('something')('something'); // => false\n * isNotEqual('something')('something else'); // => true\n * isNotEqual(['a'])(['a']); // => true\n * isNotEqual({a : 'something'})({a : 'something'}); // => true\n *\n * // isNotEqual can be called both as a curried unary function or as a standard binary function\n * isNotEqual('something')('something else') === isNotEqual('something', 'something else');\n */\nexport const isNotEqual = nary(a => b => a !== b);\n\n/**\n * isDeepEqual output is true if strict equality between the string conversion of a and the string conversion of b\n * is true including arrays and objects.\n *\n * isDeepEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isDeepEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isDeepEqual} from '@7urtle/lambda';\n *\n * isDeepEqual('something')('something'); // => true\n * isDeepEqual('something')('something else'); // => false\n * isDeepEqual(['a'])(['a']); // => true\n * isDeepEqual({a : 'something'})({a : 'something'}); // => true\n *\n * // isDeepEqual can be called both as a curried unary function or as a standard binary function\n * isDeepEqual('something')('something') === isDeepEqual('something', 'something');\n */\nexport const isDeepEqual = nary(a => b => isEqual(deepInspect(a))(deepInspect(b)));\n\n/**\n * isNotDeepEqual output is true if strict equality between the string conversion of a and the string conversion of b\n * is false including arrays and objects.\n *\n * isNotDeepEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isNotDeepEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isNotDeepEqual} from '@7urtle/lambda';\n *\n * isNotDeepEqual('something')('something'); // => false\n * isNotDeepEqual('something')('something else'); // => true\n * isNotDeepEqual(['a', 'b'])(['a']); // => true\n * isNotDeepEqual({a : 'something', b: c => c})({a : 'something'}); // => true\n *\n * // isNotDeepEqual can be called both as a curried unary function or as a standard binary function\n * isNotDeepEqual('something')('something else') === isNotDeepEqual('something', 'something else');\n */\nexport const isNotDeepEqual = nary(a => b => isNotEqual(deepInspect(a))(deepInspect(b)));\n\n/**\n * isTrue output is true if input is true.\n *\n * @HindleyMilner isTrue :: a -> boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {isTrue} from '@7urtle/lambda';\n *\n * isTrue(true); // => true\n * isTrue(false); // => false\n */\nexport const isTrue = isEqual(true);\n\n/**\n * isFalse output is true if input is false.\n *\n * @HindleyMilner isFalse :: a -> Boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {isFalse} from '@7urtle/lambda';\n *\n * isFalse(true); // => false\n * isFalse(false); // => true\n */\nexport const isFalse = isEqual(false);\n\n/**\n * isGreaterThan output is true if b is greater than a.\n *\n * isGreaterThan can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isGreaterThan :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isGreaterThan} from '@7urtle/lambda';\n *\n * isGreaterThan(1)(2); // => true\n * isGreaterThan(3)(2); // => false\n *\n * // isGreaterThan can be called both as a curried unary function or as a standard binary function\n * isGreaterThan(1)(2) === isGreaterThan(1, 2);\n */\nexport const isGreaterThan = nary(a => b => b > a);\n\n/**\n * isLessThan output is true if b is less than a.\n *\n * isLessThan can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isLessThan :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isLessThan} from '@7urtle/lambda';\n *\n * isLessThan(1)(2); // => false\n * isLessThan(3)(2); // => true\n *\n * // isLessThan can be called both as a curried unary function or as a standard binary function\n * isLessThan(3)(2) === isLessThan(3, 2);\n */\nexport const isLessThan = nary(a => b => b < a);\n\n/**\n * isAtLeast output is true if b is greater or equal to a.\n *\n * isAtLeast can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isAtLeast :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isAtLeast} from '@7urtle/lambda';\n *\n * isAtLeast(1)(2); // => true\n * isAtLeast(2)(2); // => true\n * isAtLeast(3)(2); // => false\n *\n * // isAtLeast can be called both as a curried unary function or as a standard binary function\n * isAtLeast(1)(2) === isAtLeast(1, 2);\n */\nexport const isAtLeast = nary(a => b => b >= a);\n\n/**\n * isAtMost output is true if b is less or equal to a.\n *\n * isAtMost can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isAtMost :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isAtMost} from '@7urtle/lambda';\n *\n * isAtMost(1)(2); // => false\n * isAtMost(2)(2); // => true\n * isAtMost(3)(2); // => true\n *\n * // isAtLeast can be called both as a curried unary function or as a standard binary function\n * isAtMost(3)(2) === isAtMost(31, 2);\n */\nexport const isAtMost = nary(a => b => b <= a);\n\n/**\n * isTypeOf output is true if b is a type of a.\n *\n * isTypeOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isTypeOf :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isTypeOf} from '@7urtle/lambda';\n *\n * isTypeOf('number')(1); // => true\n * isTypeOf('string')(1); // => false\n *\n * // isTypeOf can be called both as a curried unary function or as a standard binary function\n * isTypeOf('number')(1) === isTypeOf('number', 1);\n */\nexport const isTypeOf = nary(a => b => isEqual(typeOf(b))(a));\n\n/**\n * isNotTypeOf output is true if b is not a type of a.\n *\n * isNotTypeOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isNotTypeOf :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isNotTypeOf} from '@7urtle/lambda';\n *\n * isNotTypeOf('number')(1); // => false\n * isNotTypeOf('string')(1); // => true\n *\n * // isNotTypeOf can be called both as a curried unary function or as a standard binary function\n * isNotTypeOf('string')(1) === isNotTypeOf('string', 1);\n */\nexport const isNotTypeOf = nary(a => b => isNotEqual(typeOf(b))(a));\n\n/**\n * isString output is true if input is a string.\n *\n * @HindleyMilner isString :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isString} from '@7urtle/lambda';\n *\n * isString('string'); // => true\n * isString(1); // => false\n */\nexport const isString = isTypeOf('string');\n\n/**\n * isNotString output is true if input is not a string.\n *\n * @HindleyMilner isNotString :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotString} from '@7urtle/lambda';\n *\n * isNotString('string'); // => false\n * isNotString(1); // => true\n */\nexport const isNotString = isNotTypeOf('string');\n\n/**\n * isBoolean output is true if input is a boolean.\n *\n * @HindleyMilner isBoolean :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isBoolean} from '@7urtle/lambda';\n *\n * isBoolean(false); // => true\n * isBoolean(1); // => false\n */\nexport const isBoolean = isTypeOf('boolean');\n\n/**\n * isNotBoolean output is true if input is not a boolean.\n *\n * @HindleyMilner isNotBoolean :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotBoolean} from '@7urtle/lambda';\n *\n * isNotBoolean(false); // => false\n * isNotBoolean(1); // => true\n */\nexport const isNotBoolean = isNotTypeOf('boolean');\n\n/**\n * isNull output is true if input is a null.\n *\n * @HindleyMilner isNull :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNull} from '@7urtle/lambda';\n *\n * isNull(null); // => true\n * isNull(1); // => false\n */\nexport const isNull = isEqual(null);\n\n/**\n * isNotNull output is true if input is not a null.\n *\n * @HindleyMilner isNotNull :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotNull} from '@7urtle/lambda';\n *\n * isNotNull(null); // => false\n * isNotNull(1); // => true\n */\nexport const isNotNull = isNotEqual(null);\n\n/**\n * isUndefined output is true if input is an undefined.\n *\n * @HindleyMilner isUndefined :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isUndefined} from '@7urtle/lambda';\n *\n * isUndefined(undefined); // => true\n * isUndefined(1); // => false\n */\nexport const isUndefined = isTypeOf('undefined');\n\n/**\n * isNotUndefined output is true if input is not an undefined.\n *\n * @HindleyMilner isNotUndefined :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotUndefined} from '@7urtle/lambda';\n *\n * isNotUndefined(undefined); // => false\n * isNotUndefined(1); // => true\n */\nexport const isNotUndefined = isNotTypeOf('undefined');\n\n/**\n * isNumber output is true if input is a number.\n *\n * @HindleyMilner isNumber :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNumber} from '@7urtle/lambda';\n *\n * isNumber(1); // => true\n * isNumber('string'); // => false\n */\nexport const isNumber = isTypeOf('number');\n\n/**\n * isNotNumber output is true if input is not a number.\n *\n * @HindleyMilner isNotNumber :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotNumber} from '@7urtle/lambda';\n *\n * isNotNumber(1); // => false\n * isNotNumber('string'); // => true\n */\nexport const isNotNumber = isNotTypeOf('number');\n\n/**\n * isObject output is true if b is an object, array, or null.\n *\n * @HindleyMilner isObject :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isObject} from '@7urtle/lambda';\n *\n * isObject({}); // => true\n * isObject([]); // => true\n * isObject(null); // => true\n * isObject(1); // => false\n */\nexport const isObject = isTypeOf('object');\n\n/**\n * isNotObject output is true if input is not an object, array, or null.\n *\n * @HindleyMilner isNotObject :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotObject} from '@7urtle/lambda';\n *\n * isNotObject({}); // => false\n * isNotObject([]); // => false\n * isNotObject(null); // => false\n * isNotObject(1); // => true\n */\nexport const isNotObject = isNotTypeOf('object');\n\n/**\n * isArray output is true if input is an array.\n *\n * @HindleyMilner isArray :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isArray} from '@7urtle/lambda';\n *\n * isArray([]); // => true\n * isArray({}); // => false\n */\nexport const isArray = Array.isArray;\n\n/**\n * isNotArray output is true if input is not an array.\n *\n * @HindleyMilner isNotArray :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotArray} from '@7urtle/lambda';\n *\n * isNotArray([]); // => false\n * isNotArray({}); // => true\n */\nexport const isNotArray = a => !Array.isArray(a);\n\n/**\n * isFunction output is true if input is a function.\n *\n * @HindleyMilner isFunction :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isFunction} from '@7urtle/lambda';\n *\n * isFunction(() => null); // => true\n * isFunction(1); // => false\n */\nexport const isFunction = isTypeOf('function');\n\n/**\n * isNotFunction output is true if input is not a function.\n *\n * @HindleyMilner isNotFunction :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotFunction} from '@7urtle/lambda';\n *\n * isNotFunction(() => null); // => false\n * isNotFunction(1); // => true\n */\nexport const isNotFunction = isNotTypeOf('function');\n\n/**\n * isLength output is true if b is a length of a.\n *\n * @HindleyMilner isLength :: (string|array) -> b -> boolean\n *\n * @pure\n * @param {string|array} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isLength} from '@7urtle/lambda';\n *\n * isLength(3)('abc'); // => true\n * isLength(3)([1,2,3]); // => true\n * isLength(3)('abc'); // => false\n */\nexport const isLength = nary(a => b => isEqual(lengthOf(b))(a));\n\n/**\n * isNotLength output is true if b is not a length of a.\n *\n * @HindleyMilner isNotLength :: (string|array) -> b -> boolean\n *\n * @pure\n * @param {string|array} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isNotLength} from '@7urtle/lambda';\n *\n * isNotLength(3)('abc'); // => false\n * isNotLength(3)([1,2,3]); // => false\n * isNotLength(3)('abc'); // => true\n */\nexport const isNotLength = nary(a => b => !isLength(a)(b));\n\n/**\n * isEmpty output is true if input has a length of 0. isEmpty output is always false if input is an object and not\n * an array or a string.\n *\n * @HindleyMilner isEmpty :: (string|array) -> boolean\n *\n * @pure\n * @param {string|array} a\n * @return {boolean}\n *\n * @example\n * import {isEmpty} from '@7urtle/lambda';\n *\n * isEmpty(''); // => true\n * isEmpty([]); // => true\n * isEmpty('abc'); // => false\n * isEmpty({}); // => false\n */\nexport const isEmpty = isLength(0);\n\n/**\n * isNotEmpty output is true if input does not have a length of 0. isNotEmpty output is always true if input is\n * an object and not an array or a string.\n *\n * @HindleyMilner isNotEmpty :: (string|array) -> boolean\n *\n * @pure\n * @param {string|array} a\n * @return {boolean}\n *\n * @example\n * import {isNotEmpty} from '@7urtle/lambda';\n *\n * isNotEmpty(''); // => false\n * isNotEmpty([]); // => false\n * isNotEmpty('abc'); // => true\n * isNotEmpty({}); => true\n */\nexport const isNotEmpty = isNotLength(0);\n\n/**\n * isZero output is true if input is 0.\n *\n * @HindleyMilner isZero :: a -> boolean\n *\n * @pure\n * @param {number} a\n * @return {boolean}\n *\n * @example\n * import {isZero} from '@7urtle/lambda';\n *\n * isZero(0); // => true\n * isZero(1); // => false\n */\nexport const isZero = isEqual(0);\n\n/**\n * isNotZero output is true if input is not 0.\n *\n * @HindleyMilner isNotZero :: a -> boolean\n *\n * @pure\n * @param {number} a\n * @return {boolean}\n *\n * @example\n * import {isZero} from '@7urtle/lambda';\n *\n * isZero(0); // => false\n * isZero(1); // => true\n */\nexport const isNotZero = isNotEqual(0);\n\n/**\n * isNothing returns true if input is null, undefined or empty string or empty array.\n *\n * @HindleyMilner isNothing :: a -> boolean\n *\n * @pure\n * @param {number} a\n * @return {boolean}\n *\n * @example\n * import {isNothing} from '@7urtle/lambda';\n *\n * isNothing(null); // => true\n * isNothing(undefined); // => true\n * isNothing(''); // => true\n * isNothing([]); // => true\n * isNothing('7urtle'); // => false\n */\nexport const isNothing = a => isNull(a) || isUndefined(a) || isEmpty(a);\n\n/**\n * isJust returns true if input is not null, undefined or empty string or empty array.\n *\n * @HindleyMilner isJust :: a -> boolean\n *\n * @pure\n * @param {number} a\n * @return {boolean}\n *\n * @example\n * import {isJust} from '@7urtle/lambda';\n *\n * isJust(null); // => false\n * isJust(undefined); // => false\n * isJust(''); // => false\n * isJust([]); // => false\n * isJust('7urtle'); // => true\n */\nexport const isJust = a => !isNothing(a);","import {isArray, isEqual, isString, isObject, isFunction, isNull, isUndefined, isGreaterThan} from \"./conditional\";\nimport {keysOf, join, map} from \"./list\";\nimport {nary} from \"./arity\";\n\n/**\n * typeOf outputs a type of its input.\n *\n * @HindleyMilner typeOf :: a -> string\n *\n * @pure\n * @param {*} a\n * @return {string}\n *\n * @example\n * import {typeOf} from '@7urtle/lambda';\n *\n * typeOf('7turtle'); // => 'string'\n */\nexport const typeOf = a => typeof a;\n\n/**\n * lengthOf outputs the length of an input.\n *\n * @HindleyMilner lengthOf :: (string|array) -> number\n *\n * @pure\n * @param {string|array} a\n * @return {number}\n *\n * @example\n * import {lengthOf} from '@7urtle/lambda';\n *\n * lengthOf('7turtle'); // => 7\n * lengthOf([1,2,3]); // => 3\n * lengthOf({}); // => undefined\n */\nexport const lengthOf = a => a.length;\n\n/**\n * passThrough output is the same as input a. passThrough executes function passed as first argument.\n *\n * passThrough can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner passThrough :: function -> a -> a\n *\n * @pure\n * @param {function} fn\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {passThrough} from '@7urtle/lambda';\n *\n * passThrough(() => 'b')('a'); // => 'a'\n *\n * // isTypeOf can be called both as a curried unary function or as a standard binary function\n * passThrough(() => 'b')('a') === passThrough(() => 'b', 'a');\n */\nexport const passThrough = nary(fn => anything => {\n  fn(anything);\n  return anything;\n});\n\n/**\n * log output is the same as input and it logs the input value. log causes side effect of console.log.\n *\n * @HindleyMilner log :: a -> a\n *\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {log} from '@7urtle/lambda';\n *\n * log('anything'); // => 'anything'\n */\nexport const log = passThrough(console.log);\n\n/**\n * spy output is the same as input and it logs the deepInspect of the input. spy causes side effect of console.log.\n *\n * @HindleyMilner spy :: a -> a\n *\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {spy} from '@7urtle/lambda';\n *\n * spy([1, 'a']); // => \"[1, 'a']\"\n */\nexport const spy = passThrough(a => console.log(deepInspect(a)));\n\n/**\n * minusOneToUndefined output is the same as input or undefined if input is -1.\n *\n * Because some functions return -1 as error state, this function is created to change it into a more consistent\n * undefined output.\n *\n * @HindleyMilner minusOneToUndefined :: a -> a|boolean\n *\n * @param {*} anything\n * @return {*|boolean}\n *\n * @example\n * import {log} from '@7urtle/lambda';\n *\n * minusOneToUndefined(-1); // => undefined\n * minusOneToUndefined(0); // => 0\n * minusOneToUndefined('7urtle'); // => '7urtle'\n */\nexport const minusOneToUndefined = anything => isEqual(-1)(anything) ? undefined: anything;\n\n/**\n * inspectFunction outputs name of named function or its conversion to string.\n *\n * @HindleyMilner inspectFunction :: (a -> b) -> string\n *\n * @param {function} fn\n * @return {string}\n *\n * @example\n * import {inspectFunction} from '@7urtle/lambda';\n *\n * function namedFunction() {\n *   return null;\n * }\n *\n * inspectFunction(namedFunction); // => 'namedFunction'\n * inspectFunction(() => 'b');\n * // => `function () {\n * // =>     return 'b';\n * // => }`\n */\nexport const inspectFunction = fn => fn.name ? fn.name : String(fn);\n\n/**\n * inspectArray maps over input array [a] and outputs string representing it.\n *\n * @HindleyMilner inspectArray :: [a] -> string\n *\n * @param {array} a\n * @return {string}\n *\n * @example\n * import {inspectArray} from '@7urtle/lambda';\n *\n * function namedFunction() {\n *   return null;\n * }\n *\n * inspectArray([1, 'a']); // => \"[1, 'a']\"\n * inspectArray([namedFunction, 'a']); // => \"[namedFunction, 'a']\"\n */\nexport const inspectArray = a => `[${join(', ')(map(deepInspect)(a))}]`;\n\n/**\n * inspectString outputs string representing input.\n *\n * @HindleyMilner inspectString :: a -> string\n *\n * @param {*} a\n * @return {string}\n *\n * @example\n * import {inspectString} from '@7urtle/lambda';\n *\n * inspectString('my string'); // => \"'my string'\"\n */\nexport const inspectString = a => `'${a}'`;\n\n/**\n * inspectObject outputs string representing input.\n *\n * @HindleyMilner inspectObject :: a -> string\n *\n * @param {object} a\n * @return {string}\n *\n * @example\n * import {inspectObject} from '@7urtle/lambda';\n *\n * inspectObject({a: 'b'}); // => \"{a: 'b'}\"\n */\nexport const inspectObject = a =>\n  isFunction(a.inspect)\n    ? a.inspect()\n    : `{${join(', ')(map(join(': '))(map(k => [k, deepInspect(a[k])])(keysOf(a))))}}`\n\n/**\n * deepInspect runs recursively over input and outputs string representing the input.\n *\n * @HindleyMilner deepInspect :: a -> string\n *\n * @param {*} a\n * @return {string}\n *\n * @example\n * import {deepInspect} from '@7urtle/lambda';\n *\n * function namedFunction() {\n *   return null;\n * }\n *\n * deepInspect({a: 'b'}); // => \"{a: 'b'}\"\n * deepInspect(namedFunction); // => 'namedFunction'\n * deepInspect([1, 'a']); // => \"[1, 'a']\"\n * deepInspect('my string'); // => \"'my string'\"\n * deepInspect(undefined); // => 'undefined'\n */\nexport const deepInspect = a =>\n  isUndefined(a)\n    ? 'undefined'\n    : isNull(a)\n      ? 'null'\n      : isFunction(a)\n        ? inspectFunction(a)\n        : isArray(a)\n          ? inspectArray(a)\n          : isObject(a)\n            ? inspectObject(a)\n            : isString(a)\n              ? inspectString(a)\n              : String(a);","import {minusOneToUndefined} from './utils';\nimport {nary} from \"./arity\";\n\n/**\n * reduce executes input reducer function that over each member of input array [b] to output a single value. It is\n * the preferred way of working functionally with arrays as it is a pure function that does not cause mutations.\n *\n * reduce executes functions in reverse order to reduceRight.\n *\n * reduce can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner reduce :: a -> ((a, b) -> a) -> [b] -> a\n *\n * @pure\n * @param {*} initial\n * @param {function} reducer\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {reduce} from '@7urtle/lambda';\n *\n * const reducer = (accumulator, currentValue) => accumulator + currentValue;\n * const list = ['a', 'b', 'c'];\n *\n * reduce('start')(reducer)(list); // => startabc\n *\n * // reduce can be called both as a curried unary function or as a standard ternary function\n * reduce('start')(reducer)(list) === reduce('start', reducer, list);\n */\nexport const reduce = nary(initial => reducer => list => list.reduce(reducer, initial));\n\n/**\n * reduceRight executes input reducer function that over each member of input array [b] to output a single value. It is\n * the preferred way of working functionally with arrays as it is a pure function that does not cause mutations.\n *\n * reduceRight executes functions in reverse order to reduce.\n *\n * reduceRight can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner reduceRight :: a -> ((a, b) -> a) -> [b] -> a\n *\n * @pure\n * @param {*} initial\n * @param {function} reducer\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {reduceRight} from '@7urtle/lambda';\n *\n * const reducer = (accumulator, currentValue) => accumulator + currentValue;\n * const list = ['a', 'b', 'c'];\n *\n * reduceRight('start')(reducer)(list); // => startcba\n *\n * // reduceRight can be called both as a curried unary function or as a standard ternary function\n * reduceRight('start')(reducer)(list) === reduceRight('start', reducer, list);\n */\nexport const reduceRight = nary(initial => reducer => list => list.reduceRight(reducer, initial));\n\n/**\n * map executes input mapper over each member of input array [a] to output new array [b].\n *\n * map can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner map :: (a -> b) -> [a] -> [b]\n *\n * @pure\n * @param {function} mapper\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {map} from '@7urtle/lambda';\n *\n * const mapper = a => a + 'm';\n * const list = ['a', 'b', 'c'];\n *\n * map(mapper)(list); // => ['am', 'bm', 'cm']\n *\n * // map can be called both as a curried unary function or as a standard binary function\n * map(mapper)(list) === map(mapper, list);\n */\nexport const map = nary(mapper => list => list.map(mapper));\n\n/**\n * filter executes input checker over each member of input array [a] to filter and output filtered new array [b].\n *\n * filter can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner filter :: (a -> boolean) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {filter} from '@7urtle/lambda';\n *\n * const list = [0, 1, 2, 3]\n *\n * filter(a => a > 1)(list); // => [2, 3]\n *\n * // filter can be called both as a curried unary function or as a standard binary function\n * filter(a => a > 1)(list) === filter(a => a > 1, list);\n */\nexport const filter = nary(checker => list => list.filter(checker));\n\n/**\n * find executes input checker over each member of input array [a] and outputs the first array member that matches checker or undefined.\n *\n * find can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner find :: (a -> boolean) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {find} from '@7urtle/lambda';\n *\n * const list = [0, 1, 2, 3]\n *\n * find(a => a > 1)(list); // => 2\n * find(a => a > 3)(list); // => undefined\n *\n * // find can be called both as a curried unary function or as a standard binary function\n * find(a => a > 1)(list) === find(a => a > 1, list);\n */\nexport const find = nary(checker => list => list.find(checker));\n\n/**\n * findIndex executes input checker over each member of input array [a] and outputs the index of first array member that matches checker or undefined.\n *\n * findIndex can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner findIndex :: (a -> boolean) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {findIndex} from '@7urtle/lambda';\n *\n * const list = [2, 3, 4];\n *\n * findIndex(a => a > 2)(list); // => 1\n * findIndex(a => a > 4)(list); // => undefined\n *\n * // findIndex can be called both as a curried unary function or as a standard binary function\n * findIndex(a => a > 1)(list) === findIndex(a => a > 1, list);\n */\nexport const findIndex = nary(checker => list => minusOneToUndefined(list.findIndex(checker)));\n\n/**\n * join outputs a string created by joining input array members with input separator.\n *\n * join can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner join :: string -> [a] -> string\n *\n * @pure\n * @param {string} separator\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {join} from '@7urtle/lambda';\n *\n * const list = [2, 3, 4];\n *\n * join('')(list); // => '234'\n * join(' and ')(list); // => '2 and 3 and 4'\n * join()(list); // => '2,3,4'\n *\n * // join can be called both as a curried unary function or as a standard binary function\n * join('')(list) === join('', list);\n */\nexport const join = nary(separator => list => list.join(separator));\n\n/**\n * keysOf outputs array of string keys of input array or object.\n *\n * @HindleyMilner keysOf :: object -> [string]\n *\n * @pure\n * @param {Object|array} list\n * @return {array}\n *\n * @example\n * import {keysOf} from '@7urtle/lambda';\n *\n * keysOf([2, 3, 4]); // => ['0', '1', '2']\n * keysOf({1: 2, 2: 3}); // => ['1', '2']\n */\nexport const keysOf = Object.keys;\n\n/**\n * entriesOf outputs array of arrays of string keys and raw values of input array or object.\n *\n * @HindleyMilner entriesOf :: object -> [[string, a]]\n *\n * @pure\n * @param {Object|array} list\n * @return {array}\n *\n * @example\n * import {entriesOf} from '@7urtle/lambda';\n *\n * entriesOf([2, 3, 4]); // => [['0', 2], ['1', 3], ['2', 4]]\n * entriesOf({1: 2, 2: 3}); // => [['1', 2],['2', 3]]\n */\nexport const entriesOf = Object.entries;\n\n/**\n * everyOf outputs true if every element of input array passes input checker function as true.\n *\n * everyOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner everyOf :: (a -> boolean) -> [a] -> boolean\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {boolean}\n *\n * @example\n * import {everyOf} from '@7urtle/lambda';\n *\n * everyOf(a => a > 1)([2, 3, 4]); // => true\n * everyOf(a => a > 5)([2, 3, 4]); // => false\n *\n * // everyOf can be called both as a curried unary function or as a standard binary function\n * everyOf(a => a > 1)([2, 3, 4]) === everyOf(a => a > 1, [2, 3, 4]);\n */\nexport const everyOf = nary(checker => list => list.every(checker));\n\n/**\n * slice outputs selected array elements as an array based on input range.\n *\n * slice can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner slice :: number -> number -> [a] -> [a]\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {slice} from '@7urtle/lambda';\n *\n * slice(2)(1)([1, 2, 3, 4, 5]); // => [2]\n * slice(2)(0)([1, 2, 3, 4, 5]); // => [1, 2]\n * slice(8)(7)([1, 2, 3, 4, 5]); // => []\n *\n * // slice can be called both as a curried unary function or as a standard ternary function\n * slice(2)(1)([1, 2, 3, 4, 5]) === slice(2, 1, [1, 2, 3, 4, 5]);\n */\nexport const slice = nary(end => start => list => list.slice(start, end));\n\n/**\n * some outputs true if any element of input array passes input checker function as true.\n *\n * some can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner some :: (a -> boolean) -> [a] -> boolean\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {boolean}\n *\n * @example\n * import {some} from '@7urtle/lambda';\n *\n * someOf(a => a > 1)([2, 3, 4]); // => true\n * someOf(a => a > 5)([2, 3, 4]); // => false\n *\n * // some can be called both as a curried unary function or as a standard binary function\n * someOf(a => a > 1)([2, 3, 4]) === someOf(a => a > 1, [2, 3, 4]);\n */\nexport const someOf = nary(checker => list => list.some(checker));","import {reduce, reduceRight} from './list';\nimport {isString, isArray, isObject} from './conditional';\nimport {minusOneToUndefined, passThrough} from './utils';\nimport {nary} from \"./arity\";\n\n/**\n * identity is a function that simply passes its input to its output without changing it.\n *\n * @HindleyMilner identity :: a -> a\n *\n * @pure\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {identity} from '@7urtle/lambda';\n *\n * identity('anything');\n * // => anything\n */\nexport const identity = anything => anything;\n\n/**\n * compose is a right-to-left function composition\n * where each function receives input and hands over its output to the next function.\n *\n * compose executes functions in reverse order to pipe.\n *\n * compose(f,g)(x) is equivalent to f(g(x)).\n *\n * @HindleyMilner compose :: [(a -> b)] -> a -> (a -> b)\n *\n * @pure\n * @param {function} fns\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {compose} from '@7urtle/lambda';\n *\n * const addA = a => a + 'A';\n * const addB = a => a + 'B';\n * const addAB = compose(addA, addB);\n *\n * addAB('Order: ');\n * // => Order: BA\n */\nexport const compose = (...fns) => anything => reduceRight(anything)((v, f) => f(v))(fns);\n\n/**\n * pipe output is a left-to-right function composition\n * where each function receives input and hands over its output to the next function.\n *\n * pipe executes functions in reverse order to compose.\n *\n * pipe(f,g)(x) is equivalent to g(f(x)).\n *\n * @HindleyMilner pipe :: [(a -> b)] -> a -> (a -> b)\n *\n * @pure\n * @param {function} fns\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {pipe} from '@7urtle/lambda';\n *\n * const addA = a => a + 'A';\n * const addB = a => a + 'B';\n * const addAB = pipe(addA, addB);\n *\n * addAB('Order: ');\n * // => Order: AB\n */\nexport const pipe = (...fns) => anything => reduce(anything)((v, f) => f(v))(fns);\n\n/**\n * functorMap maps function over inputted functor outputting resulting functor.\n *\n * You should use functorMap when you want to work with functors using functions\n * and functional composition rather than calling maps.\n *\n * The function can be called both as a unary functorMap(fn)(functor) and binary functorMap(fn, functor).\n *\n * @HindleyMilner functorMap :: (a -> b) -> Functor -> Functor\n *\n * @param {function} fn\n * @param {functor} functor\n * @return {functor}\n *\n * @example\n * import {functorMap, Maybe, upperCaseOf} from '@7urtle/lambda';\n *\n * // the function upperCaseOf is applied to the value of the functor\n * functorMap(upperCaseOf)(Maybe.of('something')); // => Just('SOMETHING')\n *\n * // use of functorMap equals the use of map on the functor\n * functorMap(upperCaseOf)(Maybe.of('something')).value === Maybe.of('something').map(upperCaseOf).value;\n *\n * // functorMap can be called both as a curried unary function or as a standard binary function\n * functorMap(upperCaseOf)(Maybe.of('something')).value === functorMap(upperCaseOf, Maybe.of('something')).value;\n */\nexport const functorMap = nary(fn => functor => functor.map(fn));\n\n/**\n * functorFlatMap maps function over inputted functor outputting resulting flattened functor.\n *\n * You should use functorFlatMap when you want to work with functors using functions\n * and functional composition rather than calling flatMaps.\n *\n * The function can be called both as a unary functorFlatMap(fn)(functor) and binary functorFlatMap(fn, functor).\n *\n * @HindleyMilner functorFlatMap :: (a -> Functor) -> Functor -> Functor\n *\n * @param {function} fn\n * @param {functor} functor\n * @return {functor}\n *\n * @example\n * import {functorFlatMap, functorMap, Maybe} from '@7urtle/lambda';\n *\n * const maybePlus2 = number => Maybe.of(number + 2);\n *\n * // the function maybePlus2 is applied to the value of the functor\n * functorFlatMap(maybePlus2)(Maybe.of(3)); // => Just(5)\n * functorMap(maybePlus2)(Maybe.of(3)); // => Just(Just(5))\n *\n * // use of functorFlatMap equals the use of flatMap on the functor\n * functorFlatMap(maybePlus2)(Maybe.of(3)).value === Maybe.of(3).flatMap(maybePlus2).value;\n *\n * // functorFlatMap can be called both as a curried unary function or as a standard binary function\n * functorFlatMap(maybePlus2)(Maybe.of(3)).value === functorFlatMap(maybePlus2, Maybe.of(3)).value;\n */\nexport const functorFlatMap = nary(fn => functor => functor.flatMap(fn));\n\n/**\n * liftA2 provides point-free way of writing calls over applicative functors and functions expecting 2 inputs. It\n * applies input function over both functors values providing a resulting functor.\n *\n * The function can be called both as a unary liftA2(fn)(functor)(functor) and ternary liftA2(fn, functor, functor).\n *\n * @HindleyMilner liftA2 (a -> b -> c) -> Applicative a -> Applicative b -> Applicative c\n *\n * @pure\n * @param {function} fn\n * @param {functor} ap1\n * @param {functor} ap2\n * @return {functor}\n *\n * @example\n * import {liftA2, Maybe} from '@7urtle/lambda';\n *\n * const add = a => b => a + b;\n *\n * // function add which expects two inputs is applied to the values of two applicative functors Maybe\n * // the result is a Maybe functor with the internal value 5\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)); // => Just(5)\n *\n * // an example of applying a function over a Maybe of undefined value to demonstrate continued safety of functors\n * liftA2(add)(Maybe.of(1))(Maybe.of(undefined)).isNothing(); // => true\n *\n * // liftA2 can be called both as a curried unary function or as a standard ternary function\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)).value === liftA2(add, Maybe.of(2), Maybe.of(3)).value;\n */\nexport const liftA2 = nary(fn => ap1 => ap2 => ap1.map(fn).ap(ap2));\n\n/**\n * liftA3 provides point-free way of writing calls over applicative functors and functions expecting 3 inputs. It\n * applies input function over input functors values providing a resulting functor.\n *\n * The function can be called both as a unary liftA3(fn)(functor)(functor)(functor) and quaternary liftA2(fn, functor, functor, functor).\n *\n * @HindleyMilner liftA3 (a -> b -> c -> d) -> Applicative a -> Applicative b -> Applicative c -> Applicative d\n *\n * @pure\n * @param {function} fn\n * @param {functor} ap1\n * @param {functor} ap2\n * @param {functor} ap3\n * @return {functor}\n *\n * @example\n * import {liftA3, Maybe} from '@7urtle/lambda';\n *\n * const add = a => b => c => a + b + c;\n *\n * // function add which expects three inputs is applied to the values of three applicative functors Maybe\n * // the result is a Maybe functor with the internal value 9\n * liftA3(add)(Maybe.of(2))(Maybe.of(3))(Maybe.of(4)); // => Just(5)\n *\n * // an example of applying a function over a Maybe of undefined value to demonstrate continued safety of functors\n * liftA3(add)(Maybe.of(1))(Maybe.of(2))(Maybe.of(undefined)).isNothing(); // => true\n *\n * // liftA3 can be called both as a curried unary function or as a standard quaternary function\n * liftA3(add)(Maybe.of(2))(Maybe.of(3))(Maybe.of(4)).value === liftA3(add, Maybe.of(2), Maybe.of(3), Maybe.of(4)).value;\n */\nexport const liftA3 = nary(fn => ap1 => ap2 => ap3 => ap1.map(fn).ap(ap2).ap(ap3));\n\n/**\n * contact outputs concatenated inputs of strings, arrays and objects or outputs undefined for other types.\n *\n * concat can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner concat :: a -> a|boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {concat} from '@7urtle/lambda';\n *\n * concat('cd')('ab'); // => 'abcd'\n * concat([3, 4])([1,2]); // => [1, 2, 3, 4]\n * concat({here: {here: 'there'}})({hi: 'hello'}); // => {hi: 'hello', here: {here: 'there'}}\n * concat('cd')(1); // => undefined\n *\n * // concat can be called both as a curried unary function or as a standard binary function\n * concat('cd')('ab') === concat('cd', 'ab');\n */\nexport const concat = nary(a => b =>\n  isString(b) || isArray(b)\n    ? b.concat(a)\n    : isObject(b)\n      ? {...b, ...a}\n      : undefined);\n\n/**\n * includes(a)(b) output is true if b includes a.\n *\n * includes can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner includes :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {includes} from '@7urtle/lambda';\n *\n * includes('rt')('7urtle'); // => true\n * includes(1)([1, 2, 3]) // => true\n * includes('turtle')([1, 2, 3]) // => false\n *\n * // includes can be called both as a curried unary function or as a standard binary function\n * includes('rt')('7urtle') === includes('rt', '7urtle');\n */\nexport const includes = nary(a => b => b.includes(a));\n\n/**\n * indexOf(a)(b) outputs position of input a within input b or undefined if it is not found.\n *\n * indexOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner indexOf :: a -> b -> number\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {indexOf} from '@7urtle/lambda';\n *\n * indexOf('7')('7urtle'); // => 0\n * indexOf(7)('7urtle'); // => 0\n * indexOf(2)([1, 2, 3]); // => 1\n * indexOf(4)([1, 2, 3]); // => undefined\n *\n * // indexOf can be called both as a curried unary function or as a standard binary function\n * indexOf('7')('7urtle') === indexOf('7', '7urtle');\n */\nexport const indexOf = nary(a => b => minusOneToUndefined(b.indexOf(a)));\n\n/**\n * lastIndexOf(a)(b) outputs position of input a withing input b looking from the end or it retuns undefined if it is not found.\n *\n * lastIndexOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner lastIndexOf :: a -> b -> number\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {lastIndexOf} from '@7urtle/lambda';\n *\n * lastIndexOf('urtle')('7urtle'); // => 1\n * lastIndexOf(2)([1, 2, 3, 2]); // => 3\n * lastIndexOf('8')('7urtle'); // => undefined\n *\n * // lastIndexOf can be called both as a curried unary function or as a standard binary function\n * lastIndexOf('7')('7urtle') === lastIndexOf('7', '7urtle');\n */\nexport const lastIndexOf = nary(a => b => minusOneToUndefined(b.lastIndexOf(a)));\n\n/**\n * memoize uses input memory to save output of input function and then uses it to lookup the result on a repeated run. This\n * function is not pure because the input memory is modified in the process.\n *\n * The function can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner memoize :: object -> (a -> b) -> a -> b\n *\n * @param {object} memory\n * @param {function} fn\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {memoize} from '@7urtle/lambda';\n *\n * const addTwo = a => a + 2;\n * let memory = {};\n *\n * memoize(memory)(addTwo)(1); // => 3\n * memoize(memory)(addTwo)(1); // => 3\n * memory[1]; // => 3\n *\n * // lastIndexOf can be called both as a curried unary function or as a standard ternary function\n * memoize(memory)(addTwo)(1) === memoize(memory, addTwo, 1);\n */\nexport const memoize = nary(memory => fn => anything =>\n    anything in memory ? memory[anything] : (passThrough(b => memory[anything] = b))(fn(anything)));","import {minusOneToUndefined} from './utils';\nimport {nary} from \"./arity\";\n\n/**\n * trim output is a string without white characters around it.\n *\n * @HindleyMilner trim :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {trim} from '@7urtle/lambda';\n *\n * trim(' a \\n '); // => 'a'\n */\nexport const trim = string => string.trim();\n\n/**\n * testRegEx outputs true if string b passes regular expression a.\n *\n * testRegEx can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner testRegEx :: regex -> string -> boolean\n *\n * @pure\n * @param {regex} regex\n * @param {string} string\n * @return {boolean}\n *\n * @example\n * import {testRegEx} from '@7urtle/lambda';\n *\n * testRegEx(/[a-z]/)('7urtle'); // => true\n * testRegEx(/[0-9]/)('1'); // => true\n * testRegEx(/[0-9]/)('abc'); // => false\n *\n * // testRegEx can be called both as a curried unary function or as a standard binary function\n * testRegEx(/[a-z]/)('7urtle') === testRegEx(/[a-z]/, '7urtle');\n */\nexport const testRegEx = nary(regex => string => regex.test(string));\n\n/**\n * substr outputs substring based on provided string, start and limit.\n *\n * substr can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner substr :: number -> number -> string -> string\n *\n * @pure\n * @param {number} limit\n * @param {number} start\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {substr} from '@7urtle/lambda';\n *\n * substr(3)(1)('7urtle'); // => 'urt'\n * substr(1)(0)('7urtle'); // => '7'\n * substr(1)(-1)('7urtle'); // => 'e'\n *\n * // substr can be called both as a curried unary function or as a standard ternary function\n * substr(3)(1)('7urtle') === substr(3, 1, '7urtle');\n */\nexport const substr = nary(limit => start => string => string.substr(start, limit));\n\n/**\n * firstLetterOf outputs the first letter of a provided string.\n *\n * @HindleyMilner firstLetterOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {firstLetterOf} from '@7urtle/lambda';\n *\n * firstLetterOf('7urtle'); // => '7'\n */\nexport const firstLetterOf = string => string.substr(0, 1);\n\n/**\n * lastLetterOf outputs the last letter of a provided string.\n *\n * @HindleyMilner lastLetterOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {lastLetterOf} from '@7urtle/lambda';\n *\n * lastLetterOf('7urtle'); // => 'e'\n */\nexport const lastLetterOf = string => string.substr(-1, 1);\n\n/**\n * startsWith outputs true if an input string starts with provided string.\n *\n * startsWith can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner startsWith :: string -> string -> boolean\n *\n * @pure\n * @param {string} substring\n * @param {string} string\n * @return {boolean}\n *\n * @example\n * import {startsWith} from '@7urtle/lambda';\n *\n * startsWith('7')('7urtle'); // => true\n * startsWith('7urtl')('7urtle'); // => true\n * startsWith('8urtl')('7urtle'); // => false\n *\n * // startsWith can be called both as a curried unary function or as a standard binary function\n * startsWith('7')('7urtle') === startsWith('7', '7urtle');\n */\nexport const startsWith = nary(substring => string => string.startsWith(substring));\n\n/**\n * endsWith outputs true if an input string ends with provided string.\n *\n * endsWith can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner endsWith :: string -> string -> boolean\n *\n * @pure\n * @param {string} substring\n * @param {string} string\n * @return {boolean}\n *\n * @example\n * import {endsWith} from '@7urtle/lambda';\n *\n * endsWith('7e')('7urtle'); // => true\n * endsWith('urtle')('7urtle'); // => true\n * endsWith('urtls')('7urtle'); // => false\n *\n * // endsWith can be called both as a curried unary function or as a standard binary function\n * endsWith('e')('7urtle') === endsWith('e', '7urtle');\n */\nexport const endsWith = nary(substring => string => string.endsWith(substring));\n\n/**\n * repeat outputs new string repeating input string inputted count of times.\n *\n * repeat can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner repeat :: number -> string -> string\n *\n * @pure\n * @param {number} count\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {repeat} from '@7urtle/lambda';\n *\n * repeat(2)('7urtle'); // => '7urtle7urtle'\n * repeat(0)('7urtle'); // => ''\n *\n * // repeat can be called both as a curried unary function or as a standard binary function\n * repeat(2)('7urtle') === repeat(2, '7urtle');\n */\nexport const repeat = nary(count => string => string.repeat(count));\n\n/**\n * replace outputs new string replacing input substring with input replacement string in input string.\n *\n * replace can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner replace :: string -> string -> string -> string\n *\n * @pure\n * @param {string} replacement\n * @param {string} substring\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {replace} from '@7urtle/lambda';\n *\n * replace('8')('7')('7urtle'); // => '8urtle'\n * replace('7')('')('7urtle'); // => '77urtle'\n * replace('')('7')('7urtle'); // => 'urtle'\n *\n * // replace can be called both as a curried unary function or as a standard ternary function\n * replace('8')('7')('7urtle') === replace('8', '7', '7urtle');\n */\nexport const replace = nary(replacement => substring => string => string.replace(substring, replacement));\n\n/**\n * search outputs position of input substring or regular expression withing input string or undefined if it is not found.\n *\n * search can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner search :: string/regex -> string -> number\n *\n * @pure\n * @param {string|regex} substring\n * @param {string} string\n * @return {number}\n *\n * @example\n * import {search} from '@7urtle/lambda';\n *\n * search('7')('7urtle'); 0\n * search('e')('7urtle'); // => 5\n * search('rt')('7urtle'); // => 2\n * search(/URT/i)('7urtle'); // => 1\n * search('8')('7urtle'); => undefined\n *\n * // search can be called both as a curried unary function or as a standard binary function\n * search('7')('7urtle') === search('7', '7urtle');\n */\nexport const search = nary(substring => string => minusOneToUndefined(string.search(substring)));\n\n/**\n * split outputs and array of an input string split by the input substring.\n *\n * split can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner split :: string -> string -> array\n *\n * @pure\n * @param {string} substring\n * @param {string} string\n * @return {array}\n *\n * @example\n * import {split} from '@7urtle/lambda';\n *\n * split(' ')('7urtles are awesome'); // => ['7urtles', 'are', 'awesome']\n * split('/')('7urtles are awesome'); // => ['7urtles are awesome']\n *\n * // split can be called both as a curried unary function or as a standard binary function\n * split(' ')('7urtles are awesome') === split(' ', '7urtles are awesome');\n */\nexport const split = nary(substring => string => string.split(substring));\n\n/**\n * lowerCaseOf outputs the lower case version of input string.\n *\n * @HindleyMilner lowerCaseOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {lowerCaseOf} from '@7urtle/lambda';\n *\n * lowerCaseOf('PeTrA'); // => 'petra'\n * lowerCaseOf('PERN LUOUK K PL BELSK DY'); // => 'pern luouk k pl belsk dy'\n */\nexport const lowerCaseOf = string => string.toLowerCase();\n\n/**\n * upperCaseOf outputs the upper case version of input string.\n *\n * @HindleyMilner upperCaseOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {upperCaseOf} from '@7urtle/lambda';\n *\n * upperCaseOf('PeTrA'); // => 'PETRA'\n * upperCaseOf('pern luouk k pl belsk dy'); // => 'PERN LUOUK K PL BELSK DY'\n */\nexport const upperCaseOf = string => string.toUpperCase();","import {deepInspect} from \"./utils\";\nimport {isUndefined} from \"./conditional\";\n\n/**\n * Case is a monad that helps you with conditional processing.\n *\n * Case expects an array of key-value pairs as its input. Case.match then matches against a key to provide its value.\n *\n * Case is internally build on a JavaScript map and turns it into an applicative functor monad.\n *\n * @example\n * import {Case, upperCaseOf, liftA2} from '@7urtle/lambda';\n *\n * // in the example we define Case using key-value pairs. Case.of() outputs an instance of Case.\n * const myCase = Case.of([[1, 'one'], ['key', 'value'], ['_', 'fallback']);\n *\n * // you reach a value by matching keys using Case.match\n * myCase.match(1); // => 'one'\n * myCase.match('key'); // => 'value'\n * myCase.match('nope'); // => 'fallback'\n *\n * // if no fallback is defined and no key is matched, we return undefined\n * Case.of([]).match('nope'); // => undefined\n *\n * // you can also inspect it by\n * myCase.inspect(); // => 'Case(...\n *\n * // as a functor the result is safely mappable (map doesn't execute over undefined matches)\n * myCase.map(value => upperCaseOf(value)).match('key'); // => 'VALUE'\n * Case.of([]).map(upperCaseOf).match('key'); // => undefined\n *\n * // as a monad Case can be safely flat mapped with other Cases (flatMap doesn't execute over undefined)\n * Case.of([[1, 'I am']]).flatMap(a => Case.of([[1, a + ' a turtle']]).match(1); // => 'I am a turtle'\n * Case.of([[1, 'I am']]).flatMap(a => Case.of([])).match(1); // => undefined\n *\n * // as an applicative functor you can apply Cases to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * liftA2(add)(Case.of([[1, 1]))(Case.of([[1, 2]])).match(1); // => 3\n * Case.of([[1, add]]).ap(Case.of([[1, 'I am']])).ap(Case.of([[1, ' a turtle']])).match(1); // => 'I am a turtle'\n * Case.of([[1, add]]).ap(Case.of([])).ap(Case.of([[1, 'I am']])).match(1); // => undefined\n */\nexport class Case {\n  constructor(x) {\n    this.match = x;\n  }\n\n  inspect() {\n    return `Case(${deepInspect(this.match)})`;\n  }\n\n  static of(x) {\n    return new Case(\n      (x => a => x.get(a) || x.get('_') || undefined)(new Map(x))\n    );\n  }\n\n  map(fn) {\n    return new Case(a => (result => isUndefined(result) ? result : fn(result))(this.match(a)));\n  }\n\n  flatMap(fn) {\n    return new Case(a => (result => isUndefined(result) ? undefined : result.match(a))(this.map(fn).match(a)));\n  }\n\n  ap(f) {\n    return this.flatMap(fn => f.map(fn));\n  }\n}","import {deepInspect} from \"./utils\";\nimport {isNothing} from \"./conditional\";\nimport {nary} from \"./arity\";\n\n/**\n * Maybe is one of the simplest and well known monads. In other languages or libraries it is also sometimes\n * called Option. Maybe is also quite similar to our monad Either.\n *\n * Maybe expects a value as its input. It is Nothing if the value is null, undefined, or empty. It returns\n * Just for all other cases.\n *\n * Maybe is called Maybe because it maybe holds a value. You want to use Maybe for situations when you don't\n * know whether there is going to be an output. It makes the situation very obvious and forces its consumers\n * to safely deal with it.\n *\n * @example\n * import {maybe, Maybe, upperCaseOf, liftA2} from '@7urtle/lambda';\n *\n * // in the example we randomly give Maybe a value or undefined. Maybe.of() outputs an instance of Maybe.\n * const myMaybe = Maybe.of(Math.random() > 0.5 ? 'random success' : undefined);\n *\n * // you could access the actual value like this\n * myMaybe.value; // => 'random success' or undefined\n *\n * // you can also inspect it by\n * myMaybe.inspect(); // => \"Just('random success')\" or \"Nothing\"\n *\n * // you can check if the value is Nothing\n * myMaybe.isNothing(); // => true or false\n * Maybe.of('abc').isNothing(); // => false\n * Maybe.of([]).isNothing(); // => true\n *\n * // you can check if the value is Just\n * myMaybe.isJust(); // => true or false\n * Maybe.of(123).isJust(); // => true\n * Maybe.of(null).isJust(); // => false\n *\n * // as a functor the value inside is safely mappable (map doesn't execute over Nothing)\n * myMaybe.map(value => upperCaseOf(value));\n * myMaybe.inspect(); // => \"Just('RANDOM SUCCESS')\" or \"Nothing\"\n *\n * // as a monad Maybe can be safely flat mapped with other Maybes (flatMap doesn't execute over Nothing)\n * Maybe.of(3).flatMap(a => Maybe.of(a + 2)).inspect(); // => 'Just(5)'\n * Maybe.of(3).flatMap(a => Maybe.of(null)).inspect(); // => 'Nothing'\n * Maybe.of(3).flatMap(a => a + 2); // => 5\n *\n * // as an applicative functor you can apply Maybes to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)); // => Just(5)\n * Maybe.of(1).map(add).ap(Maybe.of(2)).inspect(); // => 'Just(3)'\n * Maybe.of(1).map(add).ap(Maybe.of(null)).inspect(); // => 'Nothing'\n * Maybe.of(add).ap(Maybe.of(1)).ap(Maybe.of(2)).inspect(); // => 'Just(3)'\n *\n * // as an example you can use Maybe to help you work with DOM like this\n * Maybe.of(document.querySelector('#iexist')).map(a => a.offsetTop); // => Just(1240)\n * Maybe.of(document.querySelector('#idontexist')).map(a => a.offsetTop); // => Nothing\n * maybe('error: the object doesnt exist')(a => 'offset from top is ' + a)(Maybe.of(document.querySelector('#iexist')).map(a => a.offsetTop))\n */\nexport class Maybe {\n  constructor(x) {\n    this.value = x;\n  }\n\n  static of(x) {\n    return isNothing(x) ? new Nothing(x) : new Just(x) ;\n  }\n}\n\nclass Just extends Maybe {\n  inspect() {\n    return `Just(${deepInspect(this.value)})`;\n  }\n\n  isNothing() {\n    return false;\n  }\n\n  isJust() {\n    return true;\n  }\n\n  map(fn) {\n    return Maybe.of(fn(this.value));\n  }\n\n  flatMap(fn) {\n    return fn(this.value);\n  }\n\n  ap(f) {\n    return f.map(this.value);\n  }\n}\n\nclass Nothing extends Maybe {\n  inspect () {\n    return 'Nothing';\n  }\n\n  isNothing() {\n    return true\n  }\n\n  isJust() {\n    return false;\n  }\n\n  map(fn) {\n    return this;\n  }\n\n  flatMap(fn) {\n    return this;\n  }\n\n  ap(f) {\n    return this;\n  }\n}\n\n/**\n * maybe outputs result of a function onJust if input Maybe is Just or outputs input error if input Maybe is Nothing.\n *\n * maybe can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner maybe :: a -> (b -> c) -> Maybe\n *\n * @pure\n * @param {*} error\n * @param {function} onJust\n * @param {Maybe} functorMaybe\n * @return {*}\n *\n * @example\n * import {maybe, Maybe} from '@7urtle/lambda';\n *\n * maybe('error')(a => a)(Maybe.of('abc')); // => 'abc'\n * maybe('error')(a => a)(Maybe.of(undefined)); // => 'error'\n * maybe('error')(a => a)(Maybe.of(undefined)) === Maybe.of(undefined).isNothing() ? 'error' ? 'not error';\n *\n * // maybe can be called both as a curried unary function or as a standard ternary function\n * maybe('error')(a => a)(Maybe.of('abc')) === maybe('error', a => a, Maybe.of('abc'));\n */\nexport const maybe = nary(error => onJust => functorMaybe =>\n  functorMaybe.isNothing()\n    ? error\n    : onJust(functorMaybe.value));","import {deepInspect} from \"./utils\";\nimport {nary} from \"./arity\";\n\n/**\n * Either is an excellent monad for handling error states and it is fairly similar to our monad Maybe. Either.Left\n * represents an error state and Either.Right represents a success state.\n *\n * Either.of expects a value as its input. Either.of is the same as Either.Right. You can initiate Either\n * in its error state by Either.Left.\n *\n * You can also initiate it using Either.try which expects a function as an input. It is Left if an error\n * or exception is thrown. It is Right if there are no errors or exceptions.\n *\n * Either is called Either because it allows you to branch based on an error state. You want to use Either\n * for situations when you don't know whether there might be an error. It makes the very visible that an error\n * can occur and it forces the consumer to handle the situation.\n *\n * @example\n * import {either, Either, upperCaseOf, liftA2} from '@7urtle/lambda';\n *\n * // in the example we randomly give Either a value or throw an error. Either.try() outputs an instance of Either.\n * const myEither = Either.try(() => Math.random() > 0.5 ? 'random success' : throw 'random failure');\n *\n * // you can also return Either.Left or Either.Right based on a function logic\n * const myFunction = Math.random() > 0.5 ? Either.Right('random success') : Either.Left('random failure');\n *\n * // you could access the actual value like this\n * myEither.value; // => 'random success' or 'random failure'\n *\n * // you can also inspect it by\n * myEither.inspect(); // => \"Right('random success')\" or Left('random failure')\n *\n * // Either.of and Either.Right both represent success states\n * Either.of('some value').inspect() === Either.Right('some value').inspect(); // => true\n *\n * // you can check if the value is Left\n * myEither.isLeft(); // => true or false\n * Either.of('abc').isLeft(); // => false\n * Either.Right('anything').isLeft(); // => false\n * Either.Left('anything').isLeft(); // => true\n * Either.try(() => throw 'error').isLeft(); // => true\n *\n * // you can check if the value is Right\n * myEither.isRight(); // => true or false\n * Either.of('abc').isRight(); // => true\n * Either.Right('anything').isRight(); // => true\n * Either.Left('anything').isRight(); // => false\n * Either.try(() => throw 'error').isRight(); // => false\n *\n * // as a functor the value inside is safely mappable (map doesn't execute over Left)\n * myEither.map(value => upperCaseOf(value));\n * myEither.inspect(); // => \"Right('RANDOM SUCCESS')\" or \"Left('random failure')\"\n *\n * // as a monad Either can be safely flat mapped with other Eithers (flatMap doesn't execute over Left)\n * Either.of(3).flatMap(a => Either.of(a + 2)).inspect(); // => 'Right(5)'\n * Either.Left(3).flatMap(a => Either.of(null)).inspect(); // => 'Left(3)'\n * Either.of(3).flatMap(a => a + 2); // => 5\n *\n * // as an applicative functor you can apply Eithers to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * liftA2(add)(Either.of(2))(Either.of(3)); // => Right(5)\n * Either.of(1).map(add).ap(Either.of(2)).inspect(); // => 'Right(3)'\n * Either.Left(1).map(add).ap(Either.of(2)).inspect(); // => 'Left(1)'\n * Either.of(add).ap(Either.of(1)).ap(Either.of(2)).inspect(); // => 'Right(3)'\n */\nexport class Either {\n  constructor(x) {\n    this.value = x;\n  }\n\n  static of(x) {\n    return new Right(x);\n  }\n\n  static Right(x) {\n    return new Right(x);\n  }\n\n  static Left(x) {\n    return new Left(x);\n  }\n\n  static try(fn) {\n    try {\n      return new Right(fn());\n    } catch(e) {\n      return new Left(e.message);\n    }\n  }\n}\n\nclass Right extends Either {\n  inspect() {\n    return `Right(${deepInspect(this.value)})`;\n  }\n\n  isLeft() {\n    return false;\n  }\n\n  isRight() {\n    return true;\n  }\n\n  map(fn) {\n    return Either.of(fn(this.value));\n  }\n\n  flatMap(fn) {\n    return fn(this.value);\n  }\n\n  ap(f) {\n    return f.map(this.value);\n  }\n}\n\nclass Left extends Either {\n  inspect() {\n    return `Left(${deepInspect(this.value)})`;\n  }\n\n  isLeft() {\n    return true;\n  }\n\n  isRight() {\n    return false;\n  }\n\n  map() {\n    return this;\n  }\n\n  flatMap() {\n    return this;\n  }\n\n  ap() {\n    return this;\n  }\n}\n\n/**\n * either outputs result of a function onRight if input Either is Right or outputs result of a function onLeft if input Either is Left.\n *\n * either can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner either :: (a -> b) -> (b -> c) -> Either\n *\n * @pure\n * @param {function} onLeft\n * @param {function} onRight\n * @param {Either} functorEither\n * @return {*}\n *\n * @example\n * import {either, Either} from '@7urtle/lambda';\n *\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.of('abc')); // => 'success abc'\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.Left('failure')); // => 'error failure'\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.try(() => throw 'failure')); // => 'error failure'\n *\n * // either can be called both as a curried unary function or as a standard ternary function\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.of('abc')) === either(a => 'error ' + a, a => 'success ' + a, Either.of('abc'));\n */\nexport const either = nary(onLeft => onRight => functorEither =>\n  functorEither.isLeft()\n    ? onLeft(functorEither.value)\n    : onRight(functorEither.value));","import {deepInspect} from \"./utils\";\n\n/**\n * SyncEffect is a monad that allows you to safely work with synchronous side effects in JavaScript.\n *\n * SyncEffect expects as its input a function.\n *\n * SyncEffect is evaluated lazily and nothing is executed until a trigger function is called. It does not have any inner error/exception handling\n * mechanism for the effects of the trigger. Consider using the monads Maybe and Either for managing\n * the results of the trigger.\n *\n * @example\n * import {SyncEffect, log, upperCaseOf, liftA2} from '@7urtle/lambda';\n *\n * // we create SyncEffect that expects a number from 0 to 1\n * // and based on that, it returns a value or throws an error\n * const mySyncEffect = SyncEffect.of(value => value > 0.5 ? 'random success' : throw 'random failure');\n *\n * // when you are ready, you can call trigger to trigger the side effect\n * // nothing is executed until the trigger is called\n * mySyncEffect.trigger(Math.random());\n * // => returns 'random success' or throws 'random failure' depending on Math.random() value\n *\n * // you can inspect SyncEffect by\n * mySyncEffect.inspect(); // => \"SyncEffect(function...\n *\n * // as a functor the value inside is safely mappable\n * // map doesn't execute in case of an error and nothing executes until a trigger is called\n * mySyncEffect\n * .map(value => upperCaseOf(value))\n * .trigger(Math.random());\n * // => returns 'random success' or throws 'random failure' depending on Math.random() value\n *\n * // as a monad SyncEffect can be safely flat mapped with other SyncEffects\n * // flatMap doesn't execute in case of an error and nothing executes until a trigger is called\n * SyncEffect.of(() => '7turtle').flatMap(a => SyncEffect.of(() => a + 's')).trigger();\n * // => '7urtles'\n * SyncEffect.of(() => throw 'error').flatMap(a => SyncEffect.of(() => a + 's')).trigger();\n * // => throws 'error'\n *\n * // as an applicative functor you can apply SyncEffects to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * liftA2(add)(SyncEffect.of(() => 1)(SyncEffect.of(() => 2)).trigger(); // => 3\n * SyncEffect.of(() => add).ap(SyncEffect.of(() => 1)).ap(SyncEffect.of(() => 2)).trigger(); // => 3\n */\nexport class SyncEffect {\n  constructor(fn) {\n    this.trigger = fn;\n  }\n\n  inspect() {\n    return `SyncEffect(${deepInspect(this.trigger)})`;\n  }\n\n  static of(x) {\n    return new SyncEffect(x);\n  }\n\n  static wrap(x) {\n    return new SyncEffect(() => x);\n  }\n\n  map(fn) {\n    return new SyncEffect(a => fn(this.trigger(a)));\n  }\n\n  flatMap(fn) {\n    return new SyncEffect(() => {\n      return this.map(fn).trigger().trigger();\n    })\n  }\n\n  ap(f) {\n    return this.flatMap(fn => f.map(fn));\n  }\n}","import {deepInspect} from \"./utils\";\nimport {nary} from \"./arity\";\nimport {isFunction} from \"./conditional\";\n\n/**\n * AsyncEffect is a monad that allows you to safely work with asynchronous side effects in JavaScript.\n *\n * AsyncEffect expects as its input a function that takes three inputs of a reject function, a resolve function,\n * and a value. Reject function is called on failure, resolve function is called on success, and\n * value is used as an input for calculation.\n *\n * AsyncEffect is evaluated lazily and nothing is executed until a trigger function is called.\n *\n * @example\n * import {AsyncEffect, log, upperCaseOf, liftA2, liftA3} from '@7urtle/lambda';\n *\n * // we create AsyncEffect that expects a number from 0 to 1\n * // and based on that, it resolve or rejects 10 milliseconds after it is triggered\n * const myAsyncEffect = AsyncEffect\n * .of(reject => resolve => value =>\n *     setTimeout(() => value > 0.5 ? resolve('random success') : reject('random failure'), 10)\n * );\n *\n * // you can inspect AsyncEffect by\n * myAsyncEffect.inspect(); // => \"AsyncEffect(function...\n *\n * // when you are ready, you can call trigger to trigger the side effect\n * // nothing is executed until the trigger is called\n * myAsyncEffect\n * .trigger\n * (error => log(error))\n * (result => log(result))\n * (Math.random());\n * // => logs 'random success' or 'random failure' depending on Math.random() value\n *\n * // you can also turn AsyncEffect into a JavaScript Promise\n * myAsyncEffect\n * .promise(Math.random())\n * .then(result => log(result), error => log(error));\n * // => logs 'random success' or 'random failure' depending on Math.random() value\n *\n * // thrown exceptions lead AsyncEffect to reject\n * AsyncEffect\n * .of(() => {\n *     throw 'error';\n * })\n * .trigger(log)(log)();\n * // => logs 'error'\n *\n * // as a functor the value inside is safely mappable\n * // map doesn't execute in case of an error and nothing executes until a trigger is called\n * myAsyncEffect\n * .map(value => upperCaseOf(value))\n * .trigger(log)(log)(Math.random());\n * // => logs 'RANDOM SUCCESS' or 'random failure' depending on Math.random() value\n *\n * // as a monad AsyncEffect can be safely flat mapped with other AsyncEffects\n * // flatMap doesn't execute in case of an error and nothing executes until a trigger is called\n * AsyncEffect\n * .of(reject => resolve => value => resolve(value))\n * .flatMap(a => AsyncEffect.of(reject => resolve => value => resolve(a + 's')))\n * .trigger(log)(log)('7urtle');\n * // => logs '7urtles'\n *\n * // as an applicative functor you can apply AsyncEffects to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * const AS1 = AsyncEffect.of(reject => resolve => value => resolve(1));\n * const AS2 = AsyncEffect.of(reject => resolve => value => resolve(2));\n * liftA2(add)(AS1)(AS2); // => resolve(3)\n *\n * const ASFail = AsyncEffect.of(() => throw 'error');\n * liftA3(add)(ASFail)(AS1)(AS2); // => reject('error')\n *\n * // AsyncEffect.of as well as AsyncEffect.trigger accept both curried and ternary functions\n * AsyncEffect.of((reject, resolve, value) => resolve(value)).trigger(log, log, '7urtle'); // logs '7urtle'\n *\n * // as an example you can use AsyncEffect to help you work with axios\n * AsyncEffect\n * .of(reject => resolve => value => axios.get(value).then(resolve, reject))\n * .map(toUpperCaseOf)\n * .trigger\n * (error => log(error))\n * (result => log(response.data))\n * ('/my/ajax/url');\n */\nexport class AsyncEffect {\n  constructor(fn) {\n    this.trigger = nary(reject => resolve => value => {\n      try {\n        const result = fn(reject, resolve, value);\n        return isFunction(result) ? result(resolve)(value) : result;\n      } catch(error) {\n        reject(error);\n      }\n    })\n  }\n\n  inspect() {\n    return `AsyncEffect(${deepInspect(this.trigger)})`;\n  }\n\n  static of(fn) {\n    return new AsyncEffect(fn);\n  }\n\n  promise(value) {\n    return new Promise((resolve, reject) => this.trigger(reject)(resolve)(value));\n  }\n\n  map(fn) {\n    return new AsyncEffect(reject => resolve => value => this.trigger(reject)(a => resolve(fn(a)))(value));\n  }\n\n  flatMap(fn) {\n    return new AsyncEffect(reject => resolve => value => this.trigger(reject)(x => fn(x).trigger(reject)(resolve)(value))(value));\n  }\n\n  ap(f) {\n    return this.flatMap(fn => f.map(fn));\n  }\n}"],"sourceRoot":""}